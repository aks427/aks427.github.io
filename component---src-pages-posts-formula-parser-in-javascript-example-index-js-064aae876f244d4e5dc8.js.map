{"version":3,"sources":["webpack:///./src/examples/formula-parser-in-javascript/SyntaxTokenizer.js","webpack:///./src/examples/formula-parser-in-javascript/Functions.js","webpack:///./src/examples/formula-parser-in-javascript/Validation.js","webpack:///./src/examples/formula-parser-in-javascript/FormulaEditor.js","webpack:///./src/examples/formula-parser-in-javascript/Lexer.js","webpack:///./src/examples/formula-parser-in-javascript/NodeGenerator.js","webpack:///./src/examples/formula-parser-in-javascript/Evaluator.js","webpack:///./src/examples/formula-parser-in-javascript/useForm.js","webpack:///./src/pages/posts/formula-parser-in-javascript/example/index.js"],"names":["SyntaxTokenizer","stream","peek","previousToken","getPreviousToken","previousTokenType","type","next","value","match","tokenIsValue","indexOf","token","operators","params","join","Number","functions","upper","length","toUpperCase","round","Math","checkIfValueIsAllowed","FormulaEditor","props","onChange","onErrorsChanged","onTokensChanged","inputRef","useRef","formattedRef","useState","textareaHeight","setTextareaHeight","tokens","setTokens","errors","setErrors","useEffect","t","formula","syntaxTokenizer","position","isEnd","substring","pattern","consume","i","startingPosition","tokenType","Error","push","Lexer","e","name","unclosedTokens","functionLevel","nonWhitespaceTokens","filter","error","toLowerCase","text","pop","unclosedToken","reversedToken","ValidateTokens","useLayoutEffect","inputRefCurrent","current","onInputScroll","scrollTop","scrollLeft","addEventListener","removeEventListener","style","height","min","scrollHeight","className","v","target","replace","ref","autoComplete","autoCorrect","autoCapitalize","spellCheck","rows","formattedText","classNames","x","key","formatText","addNode","nodes","node","lastNode","innerNodes","getInnerTokens","innerTokens","innerBrackets","EvaluateTokens","input","result","CreateNodesFromTokens","innerTokenResult","slice","console","log","JSON","stringify","EvaluateNode","parameters","map","operator","method","ExecuteOperator","ExecuteFunction","reducer","previousState","action","state","obj","parse","deepClone","propertyName","initialState","formState","dispatch","setFormula","useReducer","inputValues","setInputValue","references","a","GetReferencesFromTokens","Helmet","href"],"mappings":"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","file":"component---src-pages-posts-formula-parser-in-javascript-example-index-js-064aae876f244d4e5dc8.js","sourcesContent":["export function SyntaxTokenizer(stream) {\n  const peek = stream.peek();\n  const previousToken = stream.getPreviousToken();\n  const previousTokenType = previousToken ? previousToken.type : null;\n\n  // handle double quotes\n  if (peek === '\"') {\n    stream.next();\n    if (previousTokenType === 'string' || previousTokenType === 'start quote') {\n      return 'end quote';\n    }\n    return 'start quote';\n  }\n\n  // handle strings inside of quotes\n  if (peek !== '\"' && previousTokenType === 'start quote' && previousToken.value === '\"') {\n    if (stream.match(/^[^\"]+(?=\")/, true)) {\n      return 'string';\n    } else {\n      // didn't find end quote so select all the way to the end\n      stream.match(/^[^\"]+/, true);\n      return 'string';\n    }\n  }\n\n  // handle numbers\n  if (stream.match(/^[-]?\\d*\\.?\\d+/, false)) {\n    if (peek === '-' && previousTokenType !== 'operator' && tokenIsValue(previousToken)) {\n      // if this number is starting with a minus and there is no previous operator, then we need to be treating this as an operator instead\n      stream.next();\n      return 'operator';\n    }\n    stream.match(/^[-]?\\d*\\.?\\d+/, true);\n    return 'number';\n  }\n\n  // handle operators\n  if (['&', '*', '-', '+', '/'].indexOf(peek) > -1) {\n    stream.next();\n    return 'operator';\n  }\n\n  // handle references\n  if (previousTokenType === 'bracket' && previousToken.value === '[' && stream.match(/^[^[\\]]+(?=\\])/, true)) {\n    return 'reference-name';\n  }\n\n  // handle functions\n  if (stream.match(/^[a-zA-Z_]\\w*(?=\\()/, true)) {\n    return 'function-name';\n  }\n\n  // handle brackets\n  if ([')', ']', '(', '['].indexOf(peek) > -1) {\n    stream.next();\n    return 'bracket';\n  }\n\n  // handle comma\n  if (peek === ',') {\n    stream.next();\n    return 'comma';\n  }\n\n  // handle whitespace\n  if (stream.match(/^ +/, true)) {\n    return 'whitespace';\n  }\n\n  // mark anything else as an error\n  stream.next();\n  return 'error';\n}\n\nexport function tokenIsValue(token) {\n  if (!token) {\n    return false;\n  }\n  if (token.type === 'number' || token.type === 'end quote') {\n    return true;\n  }\n  if (token.type === 'bracket' && (token.value === ')' || token.value === ']')) {\n    return true;\n  }\n  return false;\n}\n","const operators = {\n  '&': Concatenate,\n  '+': Add,\n  '-': Subtract,\n  '/': Divide,\n  '*': Multiply,\n};\n\nexport function ExecuteOperator(operator, parameters) {\n  const method = operators[operator];\n  if (method) {\n    return method(parameters);\n  }\n  return '';\n}\n\nconst functions = {\n  upper: Upper,\n  round: Round,\n};\n\nexport function ExecuteFunction(name, parameters) {\n  const method = functions[name.toLowerCase()];\n  if (method) {\n    return method(parameters);\n  }\n  return '';\n}\n\nexport function HasFunction(name) {\n  return !!functions[name.toLowerCase()];\n}\n\nfunction Concatenate(params) {\n  return params.join('');\n}\n\nfunction Add(params) {\n  return Number(params[0]) + Number(params[1]);\n}\n\nfunction Subtract(params) {\n  return Number(params[0]) - Number(params[1]);\n}\n\nfunction Divide(params) {\n  return Number(params[0]) / Number(params[1]);\n}\n\nfunction Multiply(params) {\n  return Number(params[0]) * Number(params[1]);\n}\n\nfunction Upper(params) {\n  if (params.length > 0) {\n    return params[0].toUpperCase();\n  }\n  return '';\n}\n\nfunction Round(params) {\n  if (params.length > 0) {\n    return Math.round(params[0]);\n  }\n  return '';\n}\n","import { HasFunction } from './Functions';\nimport { tokenIsValue } from './SyntaxTokenizer';\n\nexport function ValidateTokens(tokens) {\n  const errors = [];\n  const unclosedTokens = [];\n  let previousToken = null;\n  let functionLevel = 0;\n  const nonWhitespaceTokens = tokens.filter(token => token.type !== 'whitespace');\n\n  for (let i = 0; i < nonWhitespaceTokens.length; i++) {\n    const token = nonWhitespaceTokens[i];\n\n    const previousTokenType = previousToken ? previousToken.type : null;\n\n    if (token.type === 'operator') {\n      if (!tokenIsValue(previousToken)) {\n        errors.push({ token, error: `Unexpected operator '${token.value}'` });\n      }\n      if (i === nonWhitespaceTokens.length - 1) {\n        errors.push({ token, error: `Value expected after operator '${token.value}'` });\n      }\n    }\n\n    if (token.type === 'number') {\n      if (!checkIfValueIsAllowed(previousToken)) {\n        errors.push({ token, error: 'An operator is required before the number' });\n      }\n    }\n\n    if (token.type === 'function-name') {\n      if (!checkIfValueIsAllowed(previousToken)) {\n        errors.push({ token, error: 'An operator is required before the function' });\n      }\n\n      if (!HasFunction(token.value)) {\n        errors.push({ token, error: `'${token.value}' is not a valid function` });\n      }\n    }\n\n    if (token.type === 'start quote') {\n      unclosedTokens.push({ text: '\"', type: 'reference', token });\n\n      if (!checkIfValueIsAllowed(previousToken)) {\n        errors.push({ token, error: 'An operator is required before the string' });\n      }\n    }\n\n    if (token.type === 'end quote') {\n      if (unclosedTokens.length > 0 && unclosedTokens[unclosedTokens.length - 1].text === '\"') {\n        unclosedTokens.pop();\n      }\n    }\n\n    if (token.type === 'comma') {\n      if (!functionLevel > 0) {\n        errors.push({ token, error: `Unexpected ','` });\n      }\n      if (!tokenIsValue(previousToken)) {\n        errors.push({ token, error: `Unexpected ','` });\n      }\n    }\n\n    if (token.type === 'bracket') {\n      if (token.value === '(') {\n        unclosedTokens.push({ text: '(', type: previousTokenType === 'function-name' ? 'function' : 'group', token });\n\n        if (previousTokenType === 'function-name') {\n          functionLevel += 1;\n        }\n\n        if (previousTokenType !== 'function-name' && !checkIfValueIsAllowed(previousToken)) {\n          errors.push({ token, error: 'An operator is required before the parenthesis' });\n        }\n      }\n\n      if (token.value === ')') {\n        if (unclosedTokens.length > 0 && unclosedTokens[unclosedTokens.length - 1].text === '(') {\n          if (unclosedTokens[unclosedTokens.length - 1].type === 'function') {\n            functionLevel--;\n          }\n\n          unclosedTokens.pop();\n\n          if (!tokenIsValue(previousToken) && !(previousTokenType === 'start-parenthesis' && unclosedTokens[unclosedTokens.length - 1].type === 'function')) {\n            errors.push({ token, error: `Unexpected ')'` });\n          }\n        } else {\n          errors.push({ token, error: `Unexpected ')'` });\n        }\n      }\n\n      if (token.value === '[') {\n        unclosedTokens.push({ text: '[', type: 'reference', token });\n\n        if (!checkIfValueIsAllowed(previousToken)) {\n          errors.push({ token, error: 'An operator is required before the reference' });\n        }\n      }\n\n      if (token.value === ']') {\n        if (unclosedTokens.length > 0 && unclosedTokens[unclosedTokens.length - 1].text === '[') {\n          if (previousTokenType !== 'reference-name') {\n            errors.push({ token, error: 'A reference name is required in the brackets' });\n          }\n          unclosedTokens.pop();\n        } else {\n          errors.push({ token, error: `Unexpected ']'` });\n        }\n      }\n    }\n\n    previousToken = token;\n  }\n\n  for (const unclosedToken of unclosedTokens) {\n    let reversedToken = unclosedToken.text;\n    if (unclosedToken.text === '(') {\n      reversedToken = ')';\n    } else if (unclosedToken.text === '[') {\n      reversedToken = ']';\n    }\n    errors.push({ token: unclosedToken.token, error: `Missing closing '${reversedToken}'` });\n  }\n\n  return errors;\n}\n\nfunction checkIfValueIsAllowed(previousToken) {\n  if (!previousToken) {\n    return true;\n  }\n\n  if (previousToken.type === 'operator' || previousToken.type === 'comma' || (previousToken.type === 'bracket' && previousToken.value === '(')) {\n    return true;\n  }\n  return false;\n}\n","import React, { useEffect, useLayoutEffect, useRef, useState } from 'react';\nimport { Lexer } from './Lexer';\nimport { SyntaxTokenizer } from './SyntaxTokenizer';\nimport { ValidateTokens } from './Validation';\nimport './FormulaEditor.scss';\n\nexport function FormulaEditor(props) {\n  const { value, onChange, onErrorsChanged, onTokensChanged } = props;\n  const inputRef = useRef();\n  const formattedRef = useRef();\n  const [textareaHeight, setTextareaHeight] = useState(30);\n  const [tokens, setTokens] = useState([]);\n  const [errors, setErrors] = useState([]);\n\n  useEffect(() => {\n    const t = Lexer(value, SyntaxTokenizer);\n    const e = ValidateTokens(t);\n    setTokens(t);\n    setErrors(e);\n    if (onTokensChanged) {\n      onTokensChanged(t);\n    }\n    if (onErrorsChanged) {\n      onErrorsChanged(e);\n    }\n  }, [value, onTokensChanged, onErrorsChanged]);\n\n  useLayoutEffect(() => {\n    const inputRefCurrent = inputRef.current;\n    const onInputScroll = () => {\n      formattedRef.current.scrollTop = inputRef.current.scrollTop;\n      formattedRef.current.scrollLeft = inputRef.current.scrollLeft;\n    };\n\n    inputRefCurrent.addEventListener('scroll', onInputScroll);\n    return () => {\n      inputRefCurrent.removeEventListener('scroll', onInputScroll);\n    };\n  }, [inputRef]);\n\n  useLayoutEffect(() => {\n    const updateInputHeight = () => {\n      inputRef.current.style.height = 'auto';\n      inputRef.current.style.height = `${Math.min(inputRef.current.scrollHeight + 2, 200)}px`;\n      setTextareaHeight(inputRef.current.scrollHeight + 2); // add 1px for top and bottom borders\n    };\n\n    updateInputHeight();\n  }, [value]);\n\n  const textareaOnChange = e => {\n    let v = e.target.value;\n    if (v) {\n      // disable multiline\n      v = v.replace(/(?:\\r\\n|\\r|\\n)/g, '');\n    }\n    onChange(v);\n  };\n\n  return (\n    <div className=\"formula-editor\">\n      <textarea\n        value={value}\n        onChange={textareaOnChange}\n        className=\"formula-editor-textarea\"\n        ref={inputRef}\n        autoComplete=\"off\"\n        autoCorrect=\"off\"\n        autoCapitalize=\"off\"\n        spellCheck=\"false\"\n        height={textareaHeight}\n        rows={1}\n      />\n      <div className=\"formula-editor-formatted\" ref={formattedRef}>\n        {formatText(tokens, errors)}\n      </div>\n    </div>\n  );\n}\n\nfunction formatText(tokens, errors) {\n  let formattedText = [];\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const classNames = [token.type];\n\n    const errorsForToken = errors.filter(x => x.token === token);\n    if (errorsForToken.length > 0) {\n      classNames.push('error');\n    }\n\n    formattedText.push(\n      <span key={i} className={classNames.join(' ')}>\n        {token.value}\n      </span>\n    );\n  }\n\n  return formattedText;\n}\n","export function Lexer(formula, syntaxTokenizer) {\n  let position = 0;\n  const tokens = [];\n\n  const isEnd = () => {\n    return position >= formula.length;\n  };\n  const peek = () => {\n    if (isEnd()) {\n      return null;\n    }\n    return formula.substring(position, position + 1);\n  };\n  const match = (pattern, consume) => {\n    const restOfFormula = formula.substring(position);\n    const match = restOfFormula.match(pattern);\n    if (!match || match.length > 1) {\n      return null;\n    }\n    if (consume) {\n      position += match[0].length;\n    }\n    return match[0] || null;\n  };\n  const next = () => {\n    position += 1;\n    return peek();\n  };\n  const getPreviousToken = () => {\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      if (tokens[i].type !== 'whitespace') {\n        return tokens[i];\n      }\n    }\n    return null;\n  };\n\n  while (!isEnd()) {\n    const startingPosition = position;\n    const tokenType = syntaxTokenizer({ peek, match, next, isEnd, getPreviousToken });\n\n    if (startingPosition === position) {\n      throw new Error('Tokenizer did not move forward');\n    }\n\n    const token = {\n      value: formula.substring(startingPosition, position),\n      type: tokenType,\n    };\n\n    tokens.push(token);\n  }\n\n  return tokens;\n}\n","export function CreateNodesFromTokens(tokens) {\n  const nodes = [];\n  const nonWhitespaceTokens = tokens.filter(token => token.type !== 'whitespace');\n\n  for (let i = 0; i < nonWhitespaceTokens.length; i++) {\n    const token = nonWhitespaceTokens[i];\n\n    if (['start quote', 'end quote'].indexOf(token.type) > -1) {\n      continue;\n    }\n\n    if (['string', 'number'].indexOf(token.type) > -1) {\n      addNode(nodes, {\n        type: token.type,\n        value: token.value,\n      });\n    }\n\n    if (token.type === 'operator') {\n      const lastNode = nodes[nodes.length - 1];\n      nodes.pop();\n      nodes.push({\n        type: 'operator',\n        value: token.value,\n        innerNodes: [lastNode],\n      });\n    }\n\n    if (token.type === 'reference-name') {\n      addNode(nodes, {\n        type: 'reference',\n        value: token.value,\n      });\n    }\n\n    if (token.type === 'function-name') {\n      let innerTokens = [];\n\n      // move forward past the function name\n      i++;\n\n      if (nonWhitespaceTokens[i] && nonWhitespaceTokens[i].type === 'bracket' && nonWhitespaceTokens[i].value === '(') {\n        const innerTokenResult = getInnerTokens(nonWhitespaceTokens.slice(i));\n        innerTokens = innerTokenResult.tokens;\n        i += innerTokenResult.i;\n      }\n\n      addNode(nodes, {\n        type: 'function',\n        value: token.value,\n        innerNodes: CreateNodesFromTokens(innerTokens),\n      });\n    }\n\n    if (token.type === 'bracket' && token.value === '(') {\n      const innerTokenResult = getInnerTokens(nonWhitespaceTokens.slice(i));\n      i += innerTokenResult.i;\n      const innerTokens = innerTokenResult.tokens;\n\n      addNode(nodes, {\n        type: 'group',\n        innerNodes: innerTokens ? CreateNodesFromTokens(innerTokens) : null,\n      });\n    }\n  }\n  console.log(JSON.stringify(nodes));\n  return nodes;\n}\n\nfunction addNode(nodes, node) {\n  const lastNode = nodes[nodes.length - 1];\n  if (lastNode && lastNode.type === 'operator' && lastNode.innerNodes.length < 2) {\n    lastNode.innerNodes.push(node);\n  } else {\n    nodes.push(node);\n  }\n}\n\nfunction getInnerTokens(tokens) {\n  const innerTokens = [];\n  const innerBrackets = [];\n  let i;\n  for (i = 0; i < tokens.length; i++) {\n    if (tokens[i].type === 'bracket') {\n      if (tokens[i].value === ')' && innerBrackets[innerBrackets.length - 1] === '(') {\n        innerBrackets.pop();\n\n        if (innerBrackets.length === 0) {\n          i++;\n          break;\n        }\n      }\n      if (tokens[i].value === '(') {\n        innerBrackets.push(tokens[i].value);\n\n        if (i === 0) {\n          continue;\n        }\n      }\n    }\n\n    innerTokens.push(tokens[i]);\n  }\n\n  return { tokens: innerTokens, i: i - 1 };\n}\n","import { ExecuteFunction, ExecuteOperator } from './Functions';\nimport { CreateNodesFromTokens } from './NodeGenerator';\n\nexport function EvaluateTokens(tokens, input) {\n  const nodes = CreateNodesFromTokens(tokens);\n  let result = '';\n  for (const node of nodes) {\n    result += EvaluateNode(node, input);\n  }\n  return result;\n}\n\nfunction EvaluateNode(node, input) {\n  if (!node) {\n    return '';\n  }\n  if (node.type === 'operator') {\n    const parameters = node.innerNodes.map(x => EvaluateNode(x, input));\n    return ExecuteOperator(node.value, parameters);\n  } else if (node.type === 'function') {\n    const parameters = node.innerNodes.map(x => EvaluateNode(x, input));\n    return ExecuteFunction(node.value, parameters);\n  } else if (node.type === 'reference') {\n    return input[node.value] || '';\n  } else if (node.type === 'string') {\n    return node.value;\n  } else if (node.type === 'number') {\n    return node.value;\n  }\n  return '';\n}\n\nexport function GetReferencesFromTokens(tokens) {\n  return tokens\n    .filter(x => x.type === 'reference-name')\n    .map(x => x.value)\n    .filter((v, i, a) => a.indexOf(v) === i); // remove duplicates\n}\n","import { useReducer } from 'react';\n\nfunction reducer(previousState, action) {\n  let state = deepClone(previousState);\n  state[action.propertyName] = action.value;\n  return state;\n}\n\nexport function useForm(initialState) {\n  const [formState, dispatch] = useReducer(reducer, initialState);\n  const setValue = (propertyName, value) => {\n    dispatch({ propertyName, value });\n  };\n  return [formState, setValue];\n}\n\nfunction deepClone(obj) {\n  if (!obj) {\n    return null;\n  }\n  return JSON.parse(JSON.stringify(obj));\n}\n","import React, { useState } from 'react';\nimport { Helmet } from 'react-helmet';\nimport Layout from '../../../../components/layout';\nimport { FormulaEditor } from '../../../../examples/formula-parser-in-javascript/FormulaEditor';\nimport { EvaluateTokens, GetReferencesFromTokens } from '../../../../examples/formula-parser-in-javascript/Evaluator';\nimport { useForm } from '../../../../examples/formula-parser-in-javascript/useForm';\nimport './Example.scss';\n\nexport default () => {\n  const [formula, setFormula] = useState(`\"Hello \" & [First Name] & \"! \" & Round(1.2 + [Some Number])`);\n  const [errors, setErrors] = useState([]);\n  const [tokens, setTokens] = useState([]);\n  const [inputValues, setInputValue] = useForm({\n    'First Name': 'Andrew',\n    'Some Number': 3,\n  });\n\n  const references = GetReferencesFromTokens(tokens);\n  const result = EvaluateTokens(tokens, inputValues);\n\n  return (\n    <Layout>\n      <Helmet>\n        <title>Parser Example</title>\n      </Helmet>\n      <div className=\"formula-example\">\n        <p>\n          This is an example for the <a href=\"/posts/formula-parser-in-javascript\">Write a simple formula parser in JavaScript</a> post.\n        </p>\n        <p>This shows the editor, validator and evaluator all working together.</p>\n\n        <h3>Editor</h3>\n        <FormulaEditor value={formula} onChange={setFormula} onErrorsChanged={setErrors} onTokensChanged={setTokens} />\n        {errors.map((error, i) => (\n          <div key={i} className=\"error\">\n            {error.error}\n          </div>\n        ))}\n        {references.length > 0 ? <h3>References</h3> : null}\n        {references.map(x => (\n          <div key={x} className=\"input-value\">\n            <div>{x}</div>\n            <input value={inputValues[x] || ''} onChange={e => setInputValue(x, e.target.value)} />\n          </div>\n        ))}\n        <h3>Result</h3>\n        <div className=\"result\">{result}</div>\n      </div>\n    </Layout>\n  );\n};\n"],"sourceRoot":""}